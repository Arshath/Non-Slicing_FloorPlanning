# Non-Slicing_FloorPlanning
Non-Slicing Floor-Planning using Simulated Annealing
Non Slicing Floor Planning using Simulated Annealing
  - Parsing the circuit file, using the necessary data structures. In this case, the entire contents of the Bench file were divided into 2 categories. The Floor Planning Blocks were parsed individually and stored in a vector of class block which had various parameters like width, height, x-coordinate and y-coordinate for each corresponding block. The Nets were parsed and each net was put in a vector list of type blocks using pointers, each element in the list representing an individual net containing the connected blocks. 
  - Once the file was parsed, the vectors containing blocks was used to construct the Horizontal Constraint Graph(HCG) to obtain the x-coordinate of each block in the Floorplan and the Vertical Constraint Graph(VCHG) to obtain their y-coordinates. The construction of HCG and VCG was done using Queues. Another option explored was using Graphs from STL, but this did not seem to improve the runtime by much so was discarded. Queues turned out to be easier to implement and debug. A detailed description of the implementation can be found in the Methodology section below.
  - Simulated Annealing Engine was then implemented to swap elements from the Sequence Pair and calculate new wirelength and area based on the Boltzman constant defined. Three different moves were implemented, the first one was to swap elements in the Positive Sequence of the Sequence Pair. The second move was to swap two elements in the Negative sequence of the Sequence Pair and then the final move was to swap elements in both the Sequences. Which move was to be executed was selected randomly by generating a random number less than 3.
  - A Makefile is written to execute the same, and the run commands are shared in the Files section.

# Implementation/Methodology and Parameters chosen

  - A vector of blocks (aka Class block) was used to store the Block details - the Block Height, the Block Width, x and y coordinates, position in the positive sequence, position in the negative sequence etc. after parsing block details from the bench file. The parsing was done using spaces between block, its width and height details. The first line was parsed as the total number of blocks in the Floorplan and subsequent lines were parsed as first element being the block name followed by its width and then its height. The functions "first_not_of" and "first_of" were used to detect the intermediate spaces.
  - Next the Nets were parsed in a similar fashion. First the string "Nets" was detected and then the subseqent lines were parsed by detecting the spaces between the connected block names. Each line in the bench represented a Net, so each net contained a variable number of Blocks associated with it. These blocks for each Net were pushed to a vector list of type block (aka class block) pointers. This vector was used to calculate the Wirelength in each case. 
  - The Area was calculated by multiplying the final width and height. The width and height were being updated at each iteration. The width being the maximum of the x-coodinate of the Blocks added to the last Block's width and similarly the final height was maximum y-coordinate of the Blocks added to the height of the last Block in the vertical direction.
  - Random initial placement was performed by placing the Blocks in a vector of Floor Planning Blocks. Here the chosen initial placement was a linear arrangement of blocks. Initially both the sequence pairs were taken to be the same and after every iteration, the sequence pair was updated based on the most recent placement of Blocks.
  - For the purpose of Placement and calculation of x and y coordinates of the Blocks, HCG and VCG graphs were implemented using Queues. The Queues were of type block (see class block), were each block was added to the queue once all the preceding blocks were added to the queue i.e, from the Sequence pair, it was considered that the first element had no inputs and all other blocks were its outputs, consequenctly the second block had one input which was the first element and the blocks following it were the ouputs and so on. So, once all the blocks preceding it were added to the queue, the corresponding block was added to the queue. Once all the blocks were processed in the HCG queue, each would have its updated x-coordinate, and when the VCG queue was processed, the y-coordinate was updated.
  - The Simulated Annealing Engine was implemented for an initial temperature of 40000, decrementing in steps of 0.95 times of the current temperature, till the freezing temperature of 1 was reached. Various temperature ranges like 1000 down to 0.01 and 500 down to 0.001 were experimented with but the one used here was chosen giving an importance to the execution time. Each temperature step also had 100 iterations, which was mostly decided going by trial and error method.
  - The final Area and Wirelength were reported in 3 different files, along with x and y coordinates of each block - one where area were optimised (a extension), one where wirelength was optimized (w extension) and one where both were optimised (c extension) based on the alpha value which was a parameter used to give different weights to the Wirelength and Area differences. The chosing of Alpha was done based on the plots shown in excel sheet such that the wirelength produced by the best case scenario (w file) was better than c extension file and best case area produced by the best case scenario (a file) was better than c extension file.
  - Selection of alpha for combined Simulated Annealing is discussed in detail in the Report pdf with a graph for explaination. In the end, the value chosen was 0.2. Alpha was chosen such that it produces a value close to the best case wirelength and the best case Area which was possible when alpha was taken as 0 and 1 respectively. For this, a plot was generated (it is shown in the pdf file) where the wirelength and area were both plotted as continuous curves for different values of alpha varying from 0.1 to 0.9. Then the value was chosen such that it gave a fairly optimal wirelength value and area value. In this case that value turned out to be 0.2. The wirelength produced at 0.2 was really close to the best case wirelenth (within 5%) and the area was slightly larger than the best case area. Although a value of 0.3 or 0.4 would have worked as well, in my case the alpha value of 0.2 seemed to be the best case solution.
  - The selection of k for Simulated Annealing was mostly trial and error based. For this particular project, the value of 0.95 worked best for k. Although I experimented around with values like 0.05 and 10^(-12), the value 0.95 gave optimal results for both Area and Wirelength.

### Files in the Archive:
  - main.cpp - The code that parses the date from the bench file. Uses a class block with members to store various properties of blocks used in the bench file. Calculates and prints the Chip Area, Chip Width and Chip Height along with the Wire Length and Area into files.
  - Results.csv - This excel sheet contains details like Temperature, Number of Accepted Moves, Number of Rejected Moves, Wirelength and Area at each temperature.
  - benchfile_Sheeparamatti_Arshath.out2<x> - x can be either "a","w" or "c" based on whether Area, Wirelength or Both are being optimized. The file contains details like Initial and Final Area, Wirelength, Width and Height of Chip and the final coordinates of the Blocks.
  - Makefile - A Makefile is included to make things easier. Inside the folder containing all the mentioned files, just run "make" command. This should compile the program. To run the file run the following commands - 
  - Also each file also has its own excel file that shows the number of Accepted and Rejected Moves at different temperatures and Wirelength and Area as well. But Results.csv also gives the same information for different runs.
  - Running the files:

	  make
	./parser <filename> <-x>

	For example: make
        	     ./parser n100.fp -w

### Files Generated:
 - Results.csv and benchfile_Sheeparamatti_Arshath.out2<x>
